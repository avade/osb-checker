package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"time"

	v2 "github.com/openservicebrokerapi/osb-checker/autogenerated/models"
	osbclient "github.com/openservicebrokerapi/osb-checker/client"
	. "github.com/openservicebrokerapi/osb-checker/config"

	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/validate"
)

func testAPIVersionHeader(url, method string) error {
	params := &osbclient.BrokerRequestParams{
		URL:    url + "?accepts_incomplete=true&service_id=fake&plan_id=fake",
		Method: method,
		HeaderOption: map[string]string{
			"X-Broker-API-Version": "fake_version",
		},
		InputData: map[string]interface{}{
			"service_id": "",
			"plan_id":"",
			"organization_guid": "",
			"space_guid":"",
		},
		Username: CONF.Authentication.Username,
		Password: CONF.Authentication.Password,
	}

	res, err := osbclient.Default.Recv(params)
	if err != nil {
		return err
	}
	if !reflect.DeepEqual(res.Code, 412) {
		fmt.Println("\nres message is:", res.Code, string(res.Message))
		return fmt.Errorf("Expected %d, got %d", 412, res.Code)
	}

	return nil
}

func testAuthentication(url, method string) error {
	params := &osbclient.BrokerRequestParams{
		URL:    url + "?accepts_incomplete=true&service_id=fake&plan_id=fake",
		Method: method,
		HeaderOption: map[string]string{
			"X-Broker-API-Version": CONF.APIVersion,
		},
		InputData: map[string]interface{}{
			"service_id": "",
			"plan_id":"",
			"organization_guid": "",
			"space_guid":"",
		},
	}

	res, err := osbclient.Default.Recv(params)
	if err != nil {
		return err
	}
	if !reflect.DeepEqual(res.Code, 401) {
		return fmt.Errorf("Expected %d, got %d", 401, res.Code)
	}

	return nil
}

func testAsyncParameters(url, method string) error {
	params := &osbclient.BrokerRequestParams{
		URL:    url + "?accepts_incomplete=false&service_id=fake&plan_id=fake",
		Method: method,
		HeaderOption: map[string]string{
			"X-Broker-API-Version": CONF.APIVersion,
		},
		InputData: map[string]interface{}{
			"service_id": "",
			"plan_id":"",
			"organization_guid": "",
			"space_guid":"",
		},
		Username: CONF.Authentication.Username,
		Password: CONF.Authentication.Password,
	}

	res, err := osbclient.Default.Recv(params)
	if err != nil {
		return err
	}
	if !reflect.DeepEqual(res.Code, 422) {
		return fmt.Errorf("Expected %d, got %d", 422, res.Code)
	}

	return nil
}

type Schema interface {
	Validate(formats strfmt.Registry) error

	MarshalBinary() ([]byte, error)

	UnmarshalBinary(b []byte) error
}

func testJSONSchema(schema Schema) error {
	return schema.Validate(strfmt.Default)
}

// TODO: For provision, update and bind operation, testCatalogSchema should be
// called to assert the legality of parameters schema.
type SchemaOpts struct {
	ServiceID, PlanID  string
	Parameters         interface{}
	SchemaType, Action string
}

func testCatalogSchema(opt *SchemaOpts) error {
	_, catalog, err := osbclient.Default.GetCatalog()
	if err != nil {
		return err
	}
	if err = testJSONSchema(catalog); err != nil {
		return err
	}

	return parametersSchemaCheck(catalog, opt)
}

func parametersSchemaCheck(catalog *v2.Catalog, opt *SchemaOpts) error {
	svc := func(catalog *v2.Catalog) *v2.Service {
		for _, svc := range catalog.Services {
			if *svc.ID == opt.ServiceID {
				return svc
			}
		}
		return nil
	}(catalog)
	plan := func(svc *v2.Service) *v2.Plan {
		for _, plan := range svc.Plans {
			if *plan.ID == opt.PlanID {
				return plan
			}
		}
		return nil
	}(svc)

	// If plan.Schemas is empty, then consider it would success no matter what opt.Parameter is.
	if plan.Schemas == nil {
		return nil
	}
	var params interface{}
	switch opt.SchemaType {
	case TypeServiceInstance:
		// If plan.Schemas.ServiceInstance is empty, then consider it would success no matter
		// what opt.Parameter is.
		instance := plan.Schemas.ServiceInstance
		if instance == nil {
			return nil
		}
		if opt.Action == ActionCreate {
			// If instance.Create is empty, then consider it would success no matter
			// what opt.Parameter is.
			create := instance.Create
			if create == nil {
				return nil
			}
			params = create.Parameters
		} else {
			// If instance.Update is empty, then consider it would success no matter
			// what opt.Parameter is.
			update := instance.Update
			if update == nil {
				return nil
			}
			params = update.Parameters
		}
		break
	case TypeServiceBinding:
		// If plan.Schemas.ServiceBinding is empty, then consider it would success no matter
		// what opt.Parameter is.
		binding := plan.Schemas.ServiceBinding
		if binding == nil {
			return nil
		}
		// If binding.Create is empty, then consider it would success no matter what
		// opt.Parameter is.
		create := binding.Create
		if create == nil {
			return nil
		}
		params = create.Parameters
	}

	schema := new(spec.Schema)
	schemaJSON, _ := json.Marshal(params)
	json.Unmarshal(schemaJSON, schema)
	return validate.AgainstSchema(schema, opt.Parameters, strfmt.Default)
}

func pollInstanceLastOperationStatus(instanceID string) error {
	return pollLastOperationStatus(instanceID, "")
}

func pollBindingLastOperationStatus(instanceID, bindingID string) error {
	return pollLastOperationStatus(instanceID, bindingID)
}

func pollLastOperationStatus(instanceID, bindingID string) error {
	var lastOperationStatus = "in progress"

	for i := 0; i < CONF.MaxPollingNum; i++ {
		if lastOperationStatus != "in progress" {
			break
		}
		fmt.Printf("\n%dth polling last operation...\n", i+1)

		var code int
		var body *v2.LastOperationResource
		var err error
		if bindingID == "" {
			code, body, err = osbclient.Default.PollInstanceLastOperation(instanceID)
		} else {
			code, body, err = osbclient.Default.PollBindingLastOperation(instanceID, bindingID)
		}
		if err != nil {
			return err
		}
		if code != 200 {
			return fmt.Errorf("Expected %v, got %v", 200, code)
		}
		lastOperationStatus = *body.State
		time.Sleep(time.Duration(CONF.PollingInterval) * time.Second)
	}
	if lastOperationStatus != "succeeded" {
		return fmt.Errorf("Expected %v, got %v", "succeeded", lastOperationStatus)
	}

	return nil
}

func deepCopy(src Schema, dst Schema) error {
	srcByte, err := src.MarshalBinary()
	if err != nil {
		return err
	}

	return dst.UnmarshalBinary(srcByte)
}
