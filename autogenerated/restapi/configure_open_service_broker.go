// This file is safe to edit. Once it exists it will not be overwritten

package restapi

import (
	"crypto/tls"
	"log"
	"net/http"

	errors "github.com/go-openapi/errors"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	strfmt "github.com/go-openapi/strfmt"

	"github.com/openservicebrokerapi/osb-checker/autogenerated/models"
	"github.com/openservicebrokerapi/osb-checker/autogenerated/restapi/operations"
	"github.com/openservicebrokerapi/osb-checker/autogenerated/restapi/operations/catalog"
	"github.com/openservicebrokerapi/osb-checker/autogenerated/restapi/operations/service_bindings"
	"github.com/openservicebrokerapi/osb-checker/autogenerated/restapi/operations/service_instances"
	"github.com/openservicebrokerapi/osb-checker/autogenerated/store"
)

//go:generate swagger generate server --target ../../autogenerated --name OpenServiceBroker --spec ../swagger.yaml

var (
	maxInstanceLastOperationQueries MaxInstanceLastOperationQueries = 3
	maxBindingLastOperationQueries  MaxBindingLastOperationQueries  = 3
)

type MaxInstanceLastOperationQueries int64

func (i MaxInstanceLastOperationQueries) Reset() {
	i = 3
}

type MaxBindingLastOperationQueries int64

func (b MaxBindingLastOperationQueries) Reset() {
	b = 3
}

// checkRequest will check if version is supported by service broker, and also
// verify the authentication info. If anything goes wrong, this method would
// return the response code and false flag.
func checkRequest(version string, req *http.Request, principal interface{}) (middleware.Responder, bool) {
	// check if the version is 2.14
	if version != "2.14" {
		return catalog.NewCatalogGetPreconditionFailed(), false
	}
	// check the authentication
	username, password, ok := req.BasicAuth()
	if !ok {
		return catalog.NewCatalogGetUnauthorized(), false
	}
	cred := principal.(map[string]string)
	if username != cred["username"] || password != cred["password"] {
		return catalog.NewCatalogGetUnauthorized(), false
	}

	var resp middleware.Responder
	return resp, true
}

func configureFlags(api *operations.OpenServiceBrokerAPI) {
	// api.CommandLineOptionsGroups = []swag.CommandLineOptionsGroup{ ... }
}

func configureAPI(api *operations.OpenServiceBrokerAPI) http.Handler {
	// configure the api here
	api.ServeError = errors.ServeError

	// Set your custom logger if needed. Default one is log.Printf
	// Expected interface func(string, ...interface{})
	//
	// Example:
	api.Logger = log.Printf

	api.JSONConsumer = runtime.JSONConsumer()

	api.JSONProducer = runtime.JSONProducer()

	// Applies when the Authorization header is set with the Basic scheme
	api.BasicAuthAuth = func(user string, pass string) (interface{}, error) {
		return store.BrokerAuthCredentials, nil
	}

	// Set your custom authorizer if needed. Default one is security.Authorized()
	// Expected interface runtime.Authorizer
	//
	// Example:
	// api.APIAuthorizer = security.Authorized()
	api.CatalogCatalogGetHandler = catalog.CatalogGetHandlerFunc(func(params catalog.CatalogGetParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// return 200 OK and catalog payload
		return catalog.NewCatalogGetOK().WithPayload(store.GetCatalogPayload())
	})

	api.ServiceBindingsServiceBindingBindingHandler = service_bindings.ServiceBindingBindingHandlerFunc(func(params service_bindings.ServiceBindingBindingParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// check if the request support async
		if !*params.AcceptsIncomplete {
			return service_bindings.NewServiceBindingBindingUnprocessableEntity()
		}
		// validate if request params is validated
		if err := params.Body.Validate(strfmt.Default); err != nil {
			return service_bindings.NewServiceBindingBindingBadRequest()
		}
		if !store.CheckIfServiceIDExists(*params.Body.ServiceID) {
			return service_bindings.NewServiceBindingBindingBadRequest()
		}
		// return 409 Conflict if find service binding exists with different properties
		if store.CheckIfServiceBingdingExistsWithDifferentProperties(*params.Body.ServiceID, *params.Body.PlanID,
			params.InstanceID, params.BindingID, params.Body.Parameters) {
			return service_bindings.NewServiceBindingBindingConflict()
		}
		// return 200 OK if find service binding exists
		if store.CheckIfServiceBindingExists(*params.Body.ServiceID, *params.Body.PlanID, params.InstanceID, params.BindingID) {
			return service_bindings.NewServiceBindingBindingOK().WithPayload(&models.ServiceBinding{
				Credentials: store.CredentialsPayload,
			})
		}
		// generate binding payload and store it in store.ServiceBindingPayloadList
		bindingPayload := &store.ServiceBindingPayload{
			ServiceID:  *params.Body.ServiceID,
			PlanID:     *params.Body.PlanID,
			InstanceID: params.InstanceID,
			BindingID:  params.BindingID,
			Payload: &models.ServiceBindingResource{
				Credentials: store.CredentialsPayload,
				Parameters:  params.Body.Parameters,
			},
		}
		store.StoreServiceBindingPayload(bindingPayload)
		// return 202 Accepted after everything done
		return service_bindings.NewServiceBindingBindingAccepted()
	})

	api.ServiceBindingsServiceBindingGetHandler = service_bindings.ServiceBindingGetHandlerFunc(func(params service_bindings.ServiceBindingGetParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// find the specified binding, and return 404 if not found
		payload, err := store.FindServiceBindingPayload(params.InstanceID, params.BindingID)
		if err != nil {
			api.Logger("%v\n", err)
			return service_bindings.NewServiceBindingGetNotFound()
		}
		// return 200 OK and binding payload
		return service_bindings.NewServiceBindingGetOK().WithPayload(payload.Payload)
	})

	api.ServiceBindingsServiceBindingLastOperationGetHandler = service_bindings.ServiceBindingLastOperationGetHandlerFunc(func(params service_bindings.ServiceBindingLastOperationGetParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// run in a loop for three times and return in progress state
		if maxBindingLastOperationQueries > 0 {
			maxBindingLastOperationQueries = maxBindingLastOperationQueries - 1
			state := "in progress"
			return service_bindings.NewServiceBindingLastOperationGetOK().WithPayload(&models.LastOperationResource{
				State:       &state,
				Description: "creating service",
			})
		}
		// finish the loop and return succeeded state
		maxBindingLastOperationQueries.Reset()
		state := "succeeded"
		return service_bindings.NewServiceBindingLastOperationGetOK().WithPayload(&models.LastOperationResource{
			State:       &state,
			Description: "created service",
		})
	})

	api.ServiceBindingsServiceBindingUnbindingHandler = service_bindings.ServiceBindingUnbindingHandlerFunc(func(params service_bindings.ServiceBindingUnbindingParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// check if the request support async
		if !*params.AcceptsIncomplete {
			return service_bindings.NewServiceBindingUnbindingUnprocessableEntity()
		}
		// validate if request params is validated
		if params.ServiceID == "" || params.PlanID == "" {
			return service_bindings.NewServiceBindingUnbindingBadRequest()
		}
		// return 410 if service binding is gone
		if !store.CheckIfServiceBindingExists(params.ServiceID, params.PlanID, params.InstanceID, params.BindingID) {
			return service_bindings.NewServiceBindingUnbindingGone()
		}
		// remove service binding from store.ServiceBindingPayloadList
		store.RemoveServiceBindingPayload(params.ServiceID, params.PlanID, params.InstanceID, params.BindingID)
		// return 202 Accepted after everything done
		return service_bindings.NewServiceBindingUnbindingAccepted()
	})

	api.ServiceInstancesServiceInstanceDeprovisionHandler = service_instances.ServiceInstanceDeprovisionHandlerFunc(func(params service_instances.ServiceInstanceDeprovisionParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// check if the request support async
		if !*params.AcceptsIncomplete {
			return service_instances.NewServiceInstanceDeprovisionUnprocessableEntity()
		}
		// validate if request params is validated
		if params.ServiceID == "" || params.PlanID == "" {
			return service_instances.NewServiceInstanceDeprovisionBadRequest()
		}
		// return 410 if service instance is gone
		if !store.CheckIfServiceInstanceExists(params.ServiceID, params.PlanID, params.InstanceID) {
			return service_instances.NewServiceInstanceDeprovisionGone()
		}
		// remove service instance from store.ServiceInstancePayloadList
		store.RemoveServiceInstancePayload(params.ServiceID, params.PlanID, params.InstanceID)
		// return 202 Accepted after everything done
		return service_instances.NewServiceInstanceDeprovisionAccepted()
	})

	api.ServiceInstancesServiceInstanceGetHandler = service_instances.ServiceInstanceGetHandlerFunc(func(params service_instances.ServiceInstanceGetParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// find the specified instance, and return 404 if not found
		payload, err := store.FindServiceInstancePayload(params.InstanceID)
		if err != nil {
			api.Logger("%v\n", err)
			return service_instances.NewServiceInstanceGetNotFound()
		}
		// return 200 OK and instance payload
		return service_instances.NewServiceInstanceGetOK().WithPayload(payload.Payload)
	})

	api.ServiceInstancesServiceInstanceLastOperationGetHandler = service_instances.ServiceInstanceLastOperationGetHandlerFunc(func(params service_instances.ServiceInstanceLastOperationGetParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// run in a loop for three times and return in progress state
		if maxInstanceLastOperationQueries > 0 {
			maxInstanceLastOperationQueries = maxInstanceLastOperationQueries - 1
			state := "in progress"
			return service_instances.NewServiceInstanceLastOperationGetOK().WithPayload(&models.LastOperationResource{
				State:       &state,
				Description: "creating service",
			})
		}
		// finish the loop and return succeeded state
		maxInstanceLastOperationQueries.Reset()
		state := "succeeded"
		return service_instances.NewServiceInstanceLastOperationGetOK().WithPayload(&models.LastOperationResource{
			State:       &state,
			Description: "created service",
		})
	})

	api.ServiceInstancesServiceInstanceProvisionHandler = service_instances.ServiceInstanceProvisionHandlerFunc(func(params service_instances.ServiceInstanceProvisionParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// check if the request support async
		if !*params.AcceptsIncomplete {
			return service_instances.NewServiceInstanceProvisionUnprocessableEntity()
		}
		// validate if request params is validated
		if err := params.Body.Validate(strfmt.Default); err != nil {
			return service_instances.NewServiceInstanceProvisionBadRequest()
		}
		if !store.CheckIfServiceIDExists(*params.Body.ServiceID) ||
			!store.CheckIfPlanIDExists(*params.Body.ServiceID, *params.Body.PlanID) {
			return service_instances.NewServiceInstanceProvisionBadRequest()
		}
		// return 409 Conflict if find service instance exists with different properties
		if store.CheckIfServiceInstanceExistsWithDifferentProperties(*params.Body.ServiceID, *params.Body.PlanID,
			params.InstanceID, params.Body.Parameters) {
			return service_instances.NewServiceInstanceProvisionConflict()
		}
		// return 200 OK if find service instance exists
		if store.CheckIfServiceInstanceExists(*params.Body.ServiceID, *params.Body.PlanID, params.InstanceID) {
			return service_instances.NewServiceInstanceProvisionOK()
		}
		// generate instance payload and store it in store.ServiceInstancePayloadList
		instancePayload := &store.ServiceInstancePayload{
			InstanceID: params.InstanceID,
			Payload: &models.ServiceInstanceResource{
				ServiceID:  *params.Body.ServiceID,
				PlanID:     *params.Body.PlanID,
				Parameters: params.Body.Parameters,
			},
		}
		store.StoreServiceInstancePayload(instancePayload)
		// return 202 Accepted after everything done
		return service_instances.NewServiceInstanceProvisionAccepted()
	})

	api.ServiceInstancesServiceInstanceUpdateHandler = service_instances.ServiceInstanceUpdateHandlerFunc(func(params service_instances.ServiceInstanceUpdateParams, principal interface{}) middleware.Responder {
		// check if request header is validated, and return 401 or 412
		if resp, ok := checkRequest(params.XBrokerAPIVersion, params.HTTPRequest, principal); !ok {
			return resp
		}
		// check if the request support async
		if !*params.AcceptsIncomplete {
			return service_instances.NewServiceInstanceUpdateUnprocessableEntity()
		}
		// validate if request params is validated
		if err := params.Body.Validate(strfmt.Default); err != nil {
			return service_instances.NewServiceInstanceUpdateBadRequest()
		}
		if !store.CheckIfServiceIDExists(*params.Body.ServiceID) {
			return service_instances.NewServiceInstanceUpdateBadRequest()
		}
		// return 200 OK if find service instance exists with exactly same properties.
		if store.CheckIfServiceInstanceExists(*params.Body.ServiceID, params.Body.PlanID, params.InstanceID) &&
			!store.CheckIfServiceInstanceExistsWithDifferentProperties(*params.Body.ServiceID, params.Body.PlanID,
				params.InstanceID, params.Body.Parameters) {
			return service_instances.NewServiceInstanceUpdateOK()
		}
		// refresh service instance in store.ServiceInstancePayloadList
		store.RefreshServiceInstancePayload(params.InstanceID, params.Body.PlanID, params.Body.Parameters)
		// return 202 Accepted after everything done
		return service_instances.NewServiceInstanceUpdateAccepted()
	})

	api.ServerShutdown = func() {}

	return setupGlobalMiddleware(api.Serve(setupMiddlewares))
}

// The TLS configuration before HTTPS server starts.
func configureTLS(tlsConfig *tls.Config) {
	// Make all necessary changes to the TLS configuration here.
}

// As soon as server is initialized but not run yet, this function will be called.
// If you need to modify a config, store server instance to stop it individually later, this is the place.
// This function can be called multiple times, depending on the number of serving schemes.
// scheme value will be set accordingly: "http", "https" or "unix"
func configureServer(s *http.Server, scheme, addr string) {}

// The middleware configuration is for the handler executors. These do not apply to the swagger.json document.
// The middleware executes after routing but before authentication, binding and validation
func setupMiddlewares(handler http.Handler) http.Handler {
	return handler
}

// The middleware configuration happens before anything, this middleware also applies to serving the swagger.json document.
// So this is a good place to plug in a panic handling middleware, logging and metrics
func setupGlobalMiddleware(handler http.Handler) http.Handler {
	return handler
}
